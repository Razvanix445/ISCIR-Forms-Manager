import 'package:flutter/material.dart';

import '../../../models/client.dart';
import '../../../models/form.dart';

class RaportIscirPage1 extends StatefulWidget {
  final Client client;
  final ISCIRForm form;
  final Map<String, TextEditingController> controllers;
  final Map<String, bool> checkboxes;
  final Map<String, String> radioSelections;
  final VoidCallback onDataChanged;

  const RaportIscirPage1({
    super.key,
    required this.client,
    required this.form,
    required this.controllers,
    required this.checkboxes,
    required this.radioSelections,
    required this.onDataChanged,
  });

  @override
  State<RaportIscirPage1> createState() => _RaportIscirPage1State();
}

class _RaportIscirPage1State extends State<RaportIscirPage1> {
  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildAutoGeneratedSection(),
          const SizedBox(height: 20),
          _buildClientInfoSection(),
          const SizedBox(height: 20),
          _buildOperationSection(),
          const SizedBox(height: 20),
          _buildEquipmentDataSection(),
          const SizedBox(height: 100),
        ],
      )
    );
  }

  Widget _buildClientInfoSection() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '1. IDENTIFICARE UTILIZATOR',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
                color: Colors.blue,
              ),
            ),
            const SizedBox(height: 12),
            _buildInfoRow('Denumire:', widget.client.name),
            _buildInfoRow('Adresă:', widget.client.address),
            _buildInfoRow('Stradă:', widget.client.street),
            _buildInfoRow('Telefon:', widget.client.phone),
            _buildInfoRow('Loc amplasare:', widget.client.installationLocation),
            _buildInfoRow('Deținător:', widget.client.holder),
          ],
        ),
      ),
    );
  }

  Widget _buildOperationSection() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Operația efectuată',
              style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
            ),
            const SizedBox(height: 8),

            // Main checkbox for "Admiterea funcționării"
            CheckboxListTile(
              title: const Text('Admiterea funcționării'),
              value: widget.checkboxes['operatia_admitere'] ?? false,
              onChanged: (value) {
                setState(() {
                  widget.checkboxes['operatia_admitere'] = value ?? false;

                  // IMPORTANT: Clear radio selection when unchecked
                  if (!value!) {
                    widget.radioSelections['tip_aparat'] = '';
                  }
                });
                widget.onDataChanged(); // Trigger auto-save
              },
            ),

            // CONDITIONAL RADIO BUTTONS - Only show if "Admiterea funcționării" is checked
            if (widget.checkboxes['operatia_admitere'] == true) ...[
              const SizedBox(height: 8),
              Padding(
                padding: const EdgeInsets.only(left: 32), // Indent to show it's a sub-option
                child: Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.blue.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: Colors.blue.withOpacity(0.3)),
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Tip aparat:',
                        style: TextStyle(
                          fontWeight: FontWeight.w500,
                          color: Colors.blue.shade700,
                        ),
                      ),
                      const SizedBox(height: 8),
                      RadioListTile<String>(
                        title: const Text('Aparat nou'),
                        value: 'nou',
                        groupValue: widget.radioSelections['tip_aparat'],
                        onChanged: (value) {
                          setState(() {
                            widget.radioSelections['tip_aparat'] = value!;
                          });
                          widget.onDataChanged();
                        },
                        dense: true,
                        contentPadding: EdgeInsets.zero,
                      ),
                      RadioListTile<String>(
                        title: const Text('Aparat vechi'),
                        value: 'vechi',
                        groupValue: widget.radioSelections['tip_aparat'],
                        onChanged: (value) {
                          setState(() {
                            widget.radioSelections['tip_aparat'] = value!;
                          });
                          widget.onDataChanged();
                        },
                        dense: true,
                        contentPadding: EdgeInsets.zero,
                      ),
                    ],
                  ),
                ),
              ),
            ],

            // Other checkboxes (independent)
            CheckboxListTile(
              title: const Text('Verificare tehnică periodică'),
              value: widget.checkboxes['operatia_vtp'] ?? false,
              onChanged: (value) {
                setState(() {
                  widget.checkboxes['operatia_vtp'] = value ?? false;
                });
                widget.onDataChanged();
              },
            ),
            CheckboxListTile(
              title: const Text('Repunere în funcțiune după reparare'),
              value: widget.checkboxes['operatia_repunere'] ?? false,
              onChanged: (value) {
                setState(() {
                  widget.checkboxes['operatia_repunere'] = value ?? false;
                });
                widget.onDataChanged();
              },
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildEquipmentDataSection() {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '2. DATE PRIVIND INSTALAȚIA DE ARDERE',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
                color: Colors.blue,
              ),
            ),
            const SizedBox(height: 12),
            _buildDropdownField(
                'producator',
                'Producător',
                [
                  'Ariston',
                  'Baxi',
                  'Beretta',
                  'Bosch',
                  'Buderus',
                  'Chaffoteaux',
                  'Ferroli',
                  'Immergas',
                  'Junkers',
                  'Motan',
                  'Protherm',
                  'Riello',
                  'Saunier Duval',
                  'Vaillant',
                  'Viessmann',
                  'Westen',
                  'Altul',
                ],
                Icons.factory,
                showOtherOption: true
            ),
            const SizedBox(height: 12),
            _buildTextField('tip', 'Tip', Icons.category),
            const SizedBox(height: 12),
            _buildTextField('model', 'Model', Icons.precision_manufacturing),
            const SizedBox(height: 12),
            _buildTextField('serie_an_fabricatie', 'Serie/An fabricație', Icons.tag),
            const SizedBox(height: 12),
            _buildTextField('putere', 'Putere', Icons.power),
            const SizedBox(height: 12),
            _buildRadioGroup(
              'Cu aer',
              'cu_aer',
              ['aspirat', 'insuflat'],
              ['Aspirat', 'Insuflat'],
            ),
            const SizedBox(height: 12),
            _buildTextField('tip_combustibil', 'Tip combustibil', Icons.local_gas_station),
            const SizedBox(height: 12),
            _buildRadioGroup(
              'Cu alimentare',
              'cu_alimentare',
              ['manuala', 'automata'],
              ['Manuală', 'Automată'],
            ),
            const SizedBox(height: 12),
          ],
        ),
      ),
    );
  }

  Widget _buildTextField(String key, String label, IconData icon) {
    return TextField(
      controller: widget.controllers[key],
      decoration: InputDecoration(
        labelText: label,
        prefixIcon: Icon(icon),
        border: const OutlineInputBorder(),
      ),
      onChanged: (value) => widget.onDataChanged(),
    );
  }

  Widget _buildRadioGroup(String title, String key, List<String> values, List<String> labels) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
        const SizedBox(height: 8),
        ...values.asMap().entries.map((entry) {
          int index = entry.key;
          String value = entry.value;
          return RadioListTile<String>(
            title: Text(labels[index], style: const TextStyle(fontSize: 14)),
            value: value,
            groupValue: widget.radioSelections[key],
            onChanged: (selectedValue) {
              setState(() {
                widget.radioSelections[key] = selectedValue!;
              });
              widget.onDataChanged(); // Trigger auto-save
            },
            dense: true,
          );
        }).toList(),
      ],
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  label,
                  style: const TextStyle(
                    fontWeight: FontWeight.w500,
                    fontSize: 12,
                    color: Colors.grey,
                  ),
                ),
                const SizedBox(height: 2),
                Text(
                  value.isNotEmpty ? value : 'Not specified',
                  style: TextStyle(
                    fontSize: 14,
                    color: value.isNotEmpty ? null : Colors.grey,
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDropdownField(
      String key,
      String label,
      List<String> options,
      IconData icon, {
        bool showOtherOption = false,
      }) {
    // Get current values
    final dropdownValue = widget.radioSelections[key] ?? '';
    final textValue = widget.controllers[key]?.text ?? '';

    // Determine if "Altul" mode is active
    final isOtherSelected = showOtherOption && dropdownValue == 'Altul';

    // Determine what to show in dropdown
    String? displayValue;
    if (dropdownValue.isEmpty) {
      displayValue = null; // Show hint
    } else if (options.contains(dropdownValue)) {
      displayValue = dropdownValue; // Show selected option
    } else {
      displayValue = 'Altul'; // Custom value, so show "Altul"
    }

    return Column(
      children: [
        // Main dropdown
        DropdownButtonFormField<String>(
          value: displayValue,
          decoration: InputDecoration(
            labelText: label,
            prefixIcon: Icon(icon),
            border: const OutlineInputBorder(),
            contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          ),
          hint: Text('Selectează $label'),
          items: options.map((String option) {
            return DropdownMenuItem<String>(
              value: option,
              child: Text(option),
            );
          }).toList(),
          onChanged: (String? newValue) {
            setState(() {
              if (newValue == 'Altul') {
                // Switch to "Altul" mode - keep existing text if any
                widget.radioSelections[key] = 'Altul';
                // Don't clear the text field - let user see what they had
              } else {
                // Store the selected dropdown value
                widget.radioSelections[key] = newValue ?? '';
                // Clear the text field since we're using dropdown value
                widget.controllers[key]?.clear();
              }
            });
            widget.onDataChanged();
          },
          isExpanded: true,
        ),

        // Text field appears when "Altul" is selected
        if (isOtherSelected) ...[
          const SizedBox(height: 12),
          TextFormField(
            controller: widget.controllers[key],
            decoration: InputDecoration(
              labelText: 'Specificați $label',
              prefixIcon: Icon(Icons.edit),
              border: const OutlineInputBorder(),
              contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            ),
            onChanged: (value) {
              // The controller automatically updates, but we need to trigger save
              widget.onDataChanged();
            },
            autofocus: true, // ← Automatically focus when text field appears
          ),
        ],
      ],
    );
  }

  Widget _buildAutoGeneratedSection() {
    // Get values with fallbacks
    final reportNo = widget.form.formData['report_no'];
    final todayDate = widget.form.formData['today_date'];

    // Fallback date in correct format if needed
    final fallbackDate = () {
      final now = DateTime.now();
      return '${now.day.toString().padLeft(2, '0')}.${now.month.toString().padLeft(2, '0')}.${now.year}';
    }();

    return Card(
      color: Colors.grey.shade50,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'RAPORT DE VERIFICĂRI, ÎNCERCĂRI ȘI PROBE',
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: Colors.grey.shade600,
              ),
            ),
            const SizedBox(height: 8),
            Row(
              children: [
                Icon(Icons.confirmation_number, size: 16, color: Colors.grey),
                const SizedBox(width: 8),
                Text('Nr. ${reportNo ?? 'Se generează...'}'),
              ],
            ),
            const SizedBox(height: 4),
            Row(
              children: [
                Icon(Icons.calendar_today, size: 16, color: Colors.grey),
                const SizedBox(width: 8),
                Text('Dată: ${todayDate ?? fallbackDate}'),
              ],
            ),
          ],
        ),
      ),
    );
  }
}