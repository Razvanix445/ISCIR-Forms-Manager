import 'dart:convert';
import 'dart:typed_data';

import 'package:flutter/material.dart';
import 'package:iscir_forms_app/screens/forms/pages/raport_iscir_page1.dart';
import 'package:iscir_forms_app/screens/forms/pages/raport_iscir_page2.dart';
import 'package:iscir_forms_app/screens/forms/pages/raport_iscir_page3.dart';
import 'package:iscir_forms_app/screens/forms/pages/raport_iscir_page4.dart';
import 'package:iscir_forms_app/screens/forms/pages/raport_iscir_page5.dart';
import 'package:iscir_forms_app/screens/forms/pdf_selection_dialog.dart';
import 'package:provider/provider.dart';

import '../../models/client.dart';
import '../../models/form.dart';
import '../../providers/form_provider.dart';
import '../../services/database_service.dart';
import '../pdf/pdf_export_screen.dart';

class RaportIscirFormScreen extends StatefulWidget {
  final ISCIRForm form;
  final Client client;

  const RaportIscirFormScreen({
    super.key,
    required this.form,
    required this.client,
  });

  @override
  State<RaportIscirFormScreen> createState() => _RaportIscirFormScreenState();

}

class _RaportIscirFormScreenState extends State<RaportIscirFormScreen> {
  int _currentPage = 0;
  final PageController _pageController = PageController();
  final int _totalPages = 5;

  // TEXT CONTROLLERS for each page
  final Map<String, TextEditingController> _page1Controllers = {};
  final Map<String, TextEditingController> _page2Controllers = {};
  final Map<String, TextEditingController> _page3Controllers = {};
  final Map<String, TextEditingController> _page4Controllers = {};
  final Map<String, TextEditingController> _page5Controllers = {};

  // CHECKBOXES for each page
  final Map<String, bool> _page1Checkboxes = {};
  final Map<String, bool> _page2Checkboxes = {};
  final Map<String, bool> _page3Checkboxes = {};
  final Map<String, bool> _page4Checkboxes = {};
  final Map<String, bool> _page5Checkboxes = {};

  // RADIO BUTTONS for each page
  final Map<String, String> _page1RadioSelections = {};
  final Map<String, String> _page2RadioSelections = {};
  final Map<String, String> _page3RadioSelections = {};
  final Map<String, String> _page4RadioSelections = {};
  final Map<String, String> _page5RadioSelections = {};

  // SIGNATURES for each page (stored as Uint8List - image bytes)
  final Map<String, Uint8List?> _page5Signatures = {};

  @override
  void initState() {
    super.initState();
    _initializeAllPageData();
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      await _addAutoGeneratedFields();
      await _loadExistingData();
    });
  }

  void _initializeAllPageData() {
    _initializePage1Data();
    _initializePage2Data();
    _initializePage3Data();
    _initializePage4Data();
    _initializePage5Data();
  }

  void _initializePage1Data() {
    final page1Fields = [
      'producator', 'tip', 'model', 'serie_an_fabricatie',
      'putere', 'tip_combustibil'
    ];
    for (String field in page1Fields) {
      _page1Controllers[field] = TextEditingController();
    }

    _page1Checkboxes.addAll({
      'operatia_admitere': false,
      'operatia_vtp': true,
      'operatia_repunere': false,
    });

    _page1RadioSelections.addAll({
      'producator': '',
      'tip_aparat': '',
      'cu_aer': 'aspirat',
      'cu_alimentare': 'manuala',
    });
  }

  void _initializePage2Data() {
    _page2RadioSelections.addAll({
      'exista_instructiuni': 'DA',
      'exista_declaratie': 'DA',
      'exista_schema': 'N_A',
      'exista_documentatie': 'N_A',
      'exista_aviz': 'DA',
      'aparat_instalat': 'DA',
      'aparat_reparat': 'N_A',
      'gaze': 'DA',
      'electricitate': 'DA',
      'apa': 'DA',
      'evacuare_gaze_arse': 'DA',
      'tip_combustibil_corespunzator': 'DA',
      'asigurare_aer': 'DA',
    });
  }

  void _initializePage3Data() {
    _page3RadioSelections.addAll({
      'verificare_etanseitate': 'DA',
      'circuit_combustibil': 'DA',
      'circuit_apa': 'N_A',
      'verificare_instalatie': 'DA',
      'verificare_legare': 'DA',

      'reglat_sarcina_aparat': 'DA',

      'tip_tiraj': 'natural',
      'tiraj': 'DA',
      'presiune_rampa': 'DA',
      'presiune_arzator': 'DA',
      'presiune_focar': 'N_A',
      'temperatura_gaze_arse': 'DA',
      'verificare_etanseitate_gaze_arse': 'DA',
      'alte_masuratori': 'DA',
      'verificare_functii_protectie': 'DA',

      'verificare_parametru_presiune': 'DA',
      'verificare_parametru_temperatura': 'DA',
    });

    final page3Fields = [
      'verificare_etanseitate_valoare',
      'circuit_combustibil_valoare',
      'circuit_apa_valoare',
      'verificare_instalatie_valoare',
      'verificare_legare_valoare',

      'tiraj_valoare',
      'presiune_rampa_valoare',
      'presiune_arzator_valoare',
      'presiune_focar_valoare',
      'temperatura_gaze_arse_valoare',
      'verificare_etanseitate_gaze_arse_valoare',
      'alte_masuratori_valoare',
      'verificare_functii_protectie_valoare',

      'verificare_parametru_presiune_valoare',
      'verificare_parametru_temperatura_valoare',
    ];
    for (String field in page3Fields) {
      _page3Controllers[field] = TextEditingController();
    }
  }

  void _initializePage4Data() {
    _page4RadioSelections.addAll({
      'co_masurat': 'DA',
      'o2_masurat': 'DA',
      'no2_masurat': 'DA',
      'so2_masurat': 'N_A',
      'co2_procent': 'DA',
      'exces_de_aer': 'DA',
      'eficienta_ardere': 'DA',
    });

    final page4Fields = [
      'co_masurat_valoare',
      'o2_masurat_valoare',
      'no2_masurat_valoare',
      'so2_masurat_valoare',
      'co2_procent_valoare',
      'exces_de_aer_valoare',
      'eficienta_ardere_valoare',
    ];
    for (String field in page4Fields) {
      _page4Controllers[field] = TextEditingController();
    }
  }

  void _initializePage5Data() {
    _page5RadioSelections.addAll({
      'aparat_admis': 'admis',
    });

    _page5Signatures.clear();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('${widget.form.formType.code} - Page ${_currentPage + 1}/$_totalPages'),
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
      ),
      body: PageView(
        controller: _pageController,
        onPageChanged: (page) {
          setState(() {
            _currentPage = page;
          });
        },
        children: [
          RaportIscirPage1(client: widget.client, form: widget.form, controllers: _page1Controllers, checkboxes: _page1Checkboxes, radioSelections: _page1RadioSelections, onDataChanged: () => _autoSavePage1(),),
          RaportIscirPage2(client: widget.client, form: widget.form, controllers: _page2Controllers, checkboxes: _page2Checkboxes, tripleRadioSelections: _page2RadioSelections, onDataChanged: () => _autoSavePage2(),),
          RaportIscirPage3(client: widget.client, form: widget.form, controllers: _page3Controllers, checkboxes: _page3Checkboxes, tripleRadioSelections: _page3RadioSelections, onDataChanged: () => _autoSavePage3(),),
          RaportIscirPage4(client: widget.client, form: widget.form, controllers: _page4Controllers, checkboxes: _page4Checkboxes, tripleRadioSelections: _page4RadioSelections, onDataChanged: () => _autoSavePage4(),),
          RaportIscirPage5(client: widget.client, form: widget.form, controllers: _page5Controllers, checkboxes: _page5Checkboxes, tripleRadioSelections: _page5RadioSelections, signatures: _page5Signatures, onDataChanged: () => _autoSavePage5(), onSignatureChanged: _onPage5SignatureChanged,),
        ],
      ),
      floatingActionButton: _buildNavigationButtons(),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
    );
  }

  Widget _buildNavigationButtons() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        // Back button
        if (_currentPage > 0)
          Padding(
            padding: const EdgeInsets.only(left: 30),
            child: FloatingActionButton(
              heroTag: "back_button",
              onPressed: _goToPreviousPage,
              backgroundColor: Colors.grey,
              child: const Icon(Icons.arrow_back, color: Colors.white),
            ),
          )
        else
          const SizedBox(width: 56),

        // Next/Preview button
        Padding(
          padding: const EdgeInsets.only(right: 30),
          child: _currentPage < _totalPages - 1
              ? FloatingActionButton(
            heroTag: "next_button",
            onPressed: _goToNextPage,
            backgroundColor: Colors.blue,
            child: const Icon(Icons.arrow_forward, color: Colors.white),
          )
              : FloatingActionButton.extended(
            heroTag: "preview_button",
            onPressed: _previewPdf,
            backgroundColor: Colors.green,
            foregroundColor: Colors.white,
            icon: const Icon(Icons.picture_as_pdf),
            label: const Text('GenereazÄƒ PDF'),
          ),
        )
      ]
    );
  }

  bool _validateFormForPdf() {
    // Check if essential fields are filled
    final missingFields = <String>[];

    // Check client information
    if (widget.client.name.isEmpty) missingFields.add('Client Name');
    if (widget.client.address.isEmpty) missingFields.add('Client Address');

    // Check if report number exists
    if (!widget.form.formData.containsKey('report_no')) {
      missingFields.add('Report Number');
    }

    if (missingFields.isNotEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Missing required fields: ${missingFields.join(', ')}'),
          backgroundColor: Colors.orange,
          duration: const Duration(seconds: 4),
        ),
      );
      return false;
    }

    return true;
  }

  void _goToPreviousPage() {
    _saveCurrentPageData();
    _pageController.previousPage(
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );
  }

  void _goToNextPage() {
    _saveCurrentPageData();
    _pageController.nextPage(
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );
  }

  void _previewPdf() async {
    if (!_validateFormForPdf()) {
      return;
    }

    _saveCurrentPageData();

    // Show PDF selection dialog
    final selectedPdfType = await showDialog<String>(
      context: context,
      builder: (context) => PdfSelectionDialog(
        form: widget.form,
        client: widget.client,
        formData: _gatherCompleteFormData(),
      ),
    );

    // If user cancelled the dialog, return
    if (selectedPdfType == null) {
      return;
    }

    // Show loading dialog
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => Center(
        child: Card(
          child: Padding(
            padding: const EdgeInsets.all(20),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const CircularProgressIndicator(),
                const SizedBox(height: 16),
                Text('Preparing ${_getPdfDisplayName(selectedPdfType)} PDF...'),
              ],
            ),
          ),
        ),
      ),
    );

    Future.delayed(const Duration(milliseconds: 500), () {
      if (mounted) {
        Navigator.pop(context); // Close loading dialog

        // Collect all form data from all pages
        final Map<String, dynamic> completeFormData = _gatherCompleteFormData();

        // Navigate to PDF export screen with selected PDF type
        Navigator.of(context).push(
          MaterialPageRoute(
            builder: (context) => PdfExportScreen(
              form: widget.form,
              client: widget.client,
              formData: completeFormData,
              selectedPdfType: selectedPdfType, // Pass the selected type
            ),
          ),
        );
      }
    });
  }

  // Helper method to get display name for PDF type
  String _getPdfDisplayName(String pdfType) {
    switch (pdfType) {
      case 'raport_iscir':
        return 'Raport ISCIR';
      case 'anexa4':
        return 'Anexa 4';
      default:
        return 'PDF';
    }
  }

  Map<String, dynamic> _gatherCompleteFormData() {
    final Map<String, dynamic> completeData = {};

    // Start with existing form data from database
    completeData.addAll(widget.form.formData);

    // === PAGE 1 DATA ===
    _page1RadioSelections.forEach((key, value) {
      if (value.isNotEmpty) {
        if (value == 'Altul') {
          // If "Altul" is selected, use the text field value instead
          final textValue = _page1Controllers[key]?.text.trim() ?? '';
          if (textValue.isNotEmpty) {
            completeData[key] = textValue;
          }
        } else {
          // Use the dropdown selection
          completeData[key] = value;
        }
      }
    });

    _page1Controllers.forEach((key, controller) {
      if (!_page1RadioSelections.containsKey(key) && controller.text.trim().isNotEmpty) {
        completeData[key] = controller.text.trim();
      }
    });

    _page1Checkboxes.forEach((key, value) {
      completeData[key] = value;
    });

    // === PAGE 2 DATA ===
    _page2RadioSelections.forEach((key, value) {
      if (value.isNotEmpty) {
        completeData[key] = value;
      }
    });

    // === PAGE 3 DATA ===
    _page3RadioSelections.forEach((key, value) {
      if (value.isNotEmpty) {
        completeData[key] = value;
      }
    });

    _page3Controllers.forEach((key, controller) {
      if (controller.text.trim().isNotEmpty) {
        completeData[key] = controller.text.trim();
      }
    });

    // === PAGE 4 DATA ===
    _page4RadioSelections.forEach((key, value) {
      if (value.isNotEmpty) {
        completeData[key] = value;
      }
    });

    _page4Controllers.forEach((key, controller) {
      if (controller.text.trim().isNotEmpty) {
        completeData[key] = controller.text.trim();
      }
    });

    // === PAGE 5 DATA ===
    _page5RadioSelections.forEach((key, value) {
      if (value.isNotEmpty) {
        completeData[key] = value;
      }
    });

    // Add Page 5 signatures if they exist
    if (_page5Signatures.isNotEmpty) {
      final Map<String, String> signaturesBase64 = {};
      _page5Signatures.forEach((key, value) {
        if (value != null) {
          signaturesBase64[key] = base64Encode(value);
        }
      });
      completeData['page5_signatures'] = signaturesBase64;
    }

    // === CLIENT DATA (for PDF mapping) ===
    // Map client data to the expected field names for PDF generation
    completeData['client_name'] = widget.client.name;
    completeData['client_address'] = widget.client.address;
    completeData['client_street'] = widget.client.street;
    completeData['client_phone'] = widget.client.phone;
    completeData['client_installation_location'] = widget.client.installationLocation;
    completeData['client_holder'] = widget.client.holder;

    // Also add the alternative field names from your coordinate mapping
    completeData['nume_client'] = widget.client.firstName;
    completeData['prenume_client'] = widget.client.lastName;
    completeData['localitate_client'] = widget.client.address;
    completeData['adresa_client'] = widget.client.street;
    completeData['telefon_client'] = widget.client.phone;
    completeData['email_client'] = widget.client.email;
    completeData['loc_aparat_client'] = widget.client.installationLocation;
    completeData['detinator_client'] = widget.client.holder;

    print('=== COMPLETE FORM DATA FOR PDF ===');
    print('Total fields: ${completeData.keys.length}');
    print('Client fields: ${completeData.keys.where((k) => k.startsWith('client_') || k.startsWith('nume_')).toList()}');
    print('Equipment fields: ${completeData.keys.where((k) => ['producator', 'tip', 'model', 'serie_an_fabricatie'].contains(k)).toList()}');
    print('Page 5 signatures: ${completeData.containsKey('page5_signatures') ? (completeData['page5_signatures'] as Map).keys.toList() : 'None'}');
    print('Auto fields: report_no=${completeData['report_no']}, today_date=${completeData['today_date']}');

    return completeData;
  }

  void _saveCurrentPageData() {
    switch (_currentPage) {
      case 0:
        _savePage1Data();
        break;
      case 1:
        _savePage2Data();
        break;
      case 2:
        _savePage3Data();
        break;
      case 3:
        _savePage4Data();
        break;
      case 4:
        _savePage5Data();
        break;
    }
  }

  Future<void> _savePage1Data() async {
    final Map<String, dynamic> pageData = {};

    try {
      _page1RadioSelections.forEach((key, value) {
        if (value.isNotEmpty) {
          if (value == 'Altul') {
            // If "Altul" is selected, use the text field value instead
            final textValue = _page1Controllers[key]?.text.trim() ?? '';
            if (textValue.isNotEmpty) {
              pageData[key] = textValue;
            }
          } else {
            // Use the dropdown selection
            pageData[key] = value;
          }
        }
      });

      _page1Controllers.forEach((key, controller) {
        if (_page1RadioSelections.containsKey(key)) return;

        if (controller.text.trim().isNotEmpty) {
          pageData[key] = controller.text.trim();
        }
      });

      _page1Checkboxes.forEach((key, value) {
        pageData[key] = value;
      });

      final success = await context.read<FormProvider>().saveFormData(
        widget.form.id!,
        pageData,
      );

      if (!success) {
        print('Failed to save Page 1 data');
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Failed to save form data'),
              backgroundColor: Colors.red,
            ),
          );
        }
      } else {
        print('Page 1 data saved successfully');
      }

    } catch (e) {
      print('Error saving Page 1 data: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error saving: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _savePage2Data() async {
    final Map<String, dynamic> pageData = {};

    try {
      _page2RadioSelections.forEach((key, value) {
        if (value.isNotEmpty) {
          pageData[key] = value;
        }
      });

      final success = await context.read<FormProvider>().saveFormData(
        widget.form.id!,
        pageData,
      );

      if (!success) {
        print('Failed to save Page 2 data');
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Failed to save form data'),
              backgroundColor: Colors.red,
            ),
          );
        }
      } else {
        print('Page 2 data saved successfully');
      }

    } catch (e) {
      print('Error saving Page 2 data: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error saving: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }

    context.read<FormProvider>().saveFormData(widget.form.id!, pageData);
  }

  Future<void> _savePage3Data() async {
    final Map<String, dynamic> pageData = {};

    try {
      _page3RadioSelections.forEach((key, value) {
        if (value.isNotEmpty) {
          pageData[key] = value;
        }
      });

      _page3Controllers.forEach((key, controller) {
        if (_page3RadioSelections.containsKey(key)) return;

        if (controller.text.trim().isNotEmpty) {
          pageData[key] = controller.text.trim();
        }
      });

      _page3Checkboxes.forEach((key, value) {
        pageData[key] = value;
      });

      final success = await context.read<FormProvider>().saveFormData(
        widget.form.id!,
        pageData,
      );

      if (!success) {
        print('Failed to save Page 3 data');
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Failed to save form data'),
              backgroundColor: Colors.red,
            ),
          );
        }
      } else {
        print('Page 3 data saved successfully');
      }

    } catch (e) {
      print('Error saving Page 3 data: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error saving: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }

    context.read<FormProvider>().saveFormData(widget.form.id!, pageData);
  }

  Future<void> _savePage4Data() async {
    final Map<String, dynamic> pageData = {};

    try {
      _page4RadioSelections.forEach((key, value) {
        if (value.isNotEmpty) {
          pageData[key] = value;
        }
      });

      _page4Controllers.forEach((key, controller) {
        if (_page4RadioSelections.containsKey(key)) return;

        if (controller.text.trim().isNotEmpty) {
          pageData[key] = controller.text.trim();
        }
      });

      final success = await context.read<FormProvider>().saveFormData(
        widget.form.id!,
        pageData,
      );

      if (!success) {
        print('Failed to save Page 4 data');
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Failed to save form data'),
              backgroundColor: Colors.red,
            ),
          );
        }
      } else {
        print('Page 4 data saved successfully');
      }

    } catch (e) {
      print('Error saving Page 4 data: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error saving: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }

    context.read<FormProvider>().saveFormData(widget.form.id!, pageData);
  }

  Future<void> _savePage5Data() async {
    final Map<String, dynamic> pageData = {};

    try {
      _page5RadioSelections.forEach((key, value) {
        if (value.isNotEmpty) {
          pageData[key] = value;
        }
      });

      if (_page5Signatures.isNotEmpty) {
        final Map<String, String> signaturesBase64 = {};
        _page5Signatures.forEach((key, value) {
          if (value != null) {
            signaturesBase64[key] = base64Encode(value);
          }
        });
        pageData['page5_signatures'] = signaturesBase64;
        print('Saving Page 5 signatures: ${signaturesBase64.keys.toList()}');
      }

      final success = await context.read<FormProvider>().saveFormData(
        widget.form.id!,
        pageData,
      );

      if (!success) {
        print('Failed to save Page 5 data');
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Failed to save form data'),
              backgroundColor: Colors.red,
            ),
          );
        }
      } else {
        print('Page 5 data saved successfully');
      }

    } catch (e) {
      print('Error saving Page 5 data: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error saving: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }

    context.read<FormProvider>().saveFormData(widget.form.id!, pageData);
  }

  void _autoSavePage1() {
    print("Called auto save for page 1");
    Future.delayed(const Duration(seconds: 1), () async {
      if (mounted) {
        await _savePage1Data();
      }
    });
  }

  void _autoSavePage2() {
    print("Called auto save for page 2");
    Future.delayed(const Duration(seconds: 1), () async {
      if (mounted) {
        await _savePage2Data();
      }
    });
  }

  void _autoSavePage3() {
    print("Called auto save for page 3");
    Future.delayed(const Duration(seconds: 1), () async {
      if (mounted) {
        await _savePage3Data();
      }
    });
  }

  void _autoSavePage4() {
    print("Called auto save for page 4");
    Future.delayed(const Duration(seconds: 1), () async {
      if (mounted) {
        await _savePage4Data();
      }
    });
  }

  void _autoSavePage5() {
    print("Called auto save for page 5");
    Future.delayed(const Duration(seconds: 1), () async {
      if (mounted) {
        await _savePage5Data();
      }
    });
  }

  Future<void> _loadExistingData() async {
    _loadExistingPage1Data();
    _loadExistingPage2Data();
    _loadExistingPage3Data();
    _loadExistingPage4Data();
    _loadExistingPage5Data();
  }

  Future<void> _loadExistingPage1Data() async {
    try {
      final formData = widget.form.formData;

      if (formData.isEmpty) {
        print('No existing data to load');
        return;
      }

      print('Loading existing data: $formData');

      // Load data into Page 1 controllers
      _page1Controllers.forEach((key, controller) {
        if (formData.containsKey(key)) {
          controller.text = formData[key]?.toString() ?? '';
        }
      });

      // Load data into Page 1 radio selections
      _page1RadioSelections.forEach((key, value) {
        if (formData.containsKey(key)) {
          final savedValue = formData[key]?.toString() ?? '';

          // If this is a dropdown field with showOtherOption
          if (key == 'producator') { // Add other dropdown fields here as needed
            final dropdownOptions = [
              'Ariston', 'Baxi', 'Beretta', 'Bosch', 'Buderus',
              'Ferroli', 'Immergas', 'Junkers', 'Saunier Duval',
              'Vaillant', 'Viessmann', 'Wolf'
            ];

            if (dropdownOptions.contains(savedValue)) {
              // It's a dropdown option
              _page1RadioSelections[key] = savedValue;
              _page1Controllers[key]?.clear();
            } else if (savedValue.isNotEmpty) {
              // It's a custom value
              _page1RadioSelections[key] = 'Altul';
              _page1Controllers[key]?.text = savedValue;
            }
          } else {
            // Regular radio button
            _page1RadioSelections[key] = savedValue;
          }
        }
      });

      // Load data into Page 1 checkboxes
      _page1Checkboxes.forEach((key, value) {
        if (formData.containsKey(key)) {
          _page1Checkboxes[key] = formData[key] == true || formData[key] == 'true';
        }
      });

      // Trigger UI rebuild to show loaded data
      setState(() {});

      print('Data loaded successfully');

    } catch (e) {
      print('Error loading existing data: $e');
    }
  }

  Future<void> _loadExistingPage2Data() async {
    try {
      final formData = widget.form.formData;

      if (formData.isEmpty) {
        print('No existing data to load');
        return;
      }

      print('Loading existing data: $formData');

      // Load data into Page 2 controllers
      _page2Controllers.forEach((key, controller) {
        if (formData.containsKey(key)) {
          controller.text = formData[key]?.toString() ?? '';
        }
      });

      // Load data into Page 2 radio selections
      _page2RadioSelections.forEach((key, value) {
        if (formData.containsKey(key)) {
          final savedValue = formData[key]?.toString() ?? '';
          _page2RadioSelections[key] = savedValue;
        }
      });

      // Load data into Page 2 checkboxes
      _page2Checkboxes.forEach((key, value) {
        if (formData.containsKey(key)) {
          _page2Checkboxes[key] = formData[key] == true || formData[key] == 'true';
        }
      });

      // Trigger UI rebuild to show loaded data
      setState(() {});

      print('Data loaded successfully');

    } catch (e) {
      print('Error loading existing data: $e');
    }
  }

  Future<void> _loadExistingPage3Data() async {
    try {
      final formData = widget.form.formData;

      if (formData.isEmpty) {
        print('No existing data to load');
        return;
      }

      print('Loading existing data: $formData');

      // Load data into Page 3 controllers
      _page3Controllers.forEach((key, controller) {
        if (formData.containsKey(key)) {
          controller.text = formData[key]?.toString() ?? '';
        }
      });

      // Load data into Page 3 radio selections
      _page3RadioSelections.forEach((key, value) {
        if (formData.containsKey(key)) {
          final savedValue = formData[key]?.toString() ?? '';
          _page3RadioSelections[key] = savedValue;
        }
      });

      // Trigger UI rebuild to show loaded data
      setState(() {});

      print('Data loaded successfully');

    } catch (e) {
      print('Error loading existing data: $e');
    }
  }

  Future<void> _loadExistingPage4Data() async {
    try {
      final formData = widget.form.formData;

      if (formData.isEmpty) {
        print('No existing data to load');
        return;
      }

      print('Loading existing data: $formData');

      // Load data into Page 4 controllers
      _page4Controllers.forEach((key, controller) {
        if (formData.containsKey(key)) {
          controller.text = formData[key]?.toString() ?? '';
        }
      });

      // Load data into Page 4 radio selections
      _page4RadioSelections.forEach((key, value) {
        if (formData.containsKey(key)) {
          final savedValue = formData[key]?.toString() ?? '';
          _page4RadioSelections[key] = savedValue;
        }
      });

      // Trigger UI rebuild to show loaded data
      setState(() {});

      print('Data loaded successfully');

    } catch (e) {
      print('Error loading existing data: $e');
    }
  }

  Future<void> _loadExistingPage5Data() async {
    try {
      final formData = widget.form.formData;

      if (formData.isEmpty) {
        print('No existing data to load');
        return;
      }

      print('Loading existing data: $formData');

      // Load data into Page 5 radio selections
      _page5RadioSelections.forEach((key, value) {
        if (formData.containsKey(key)) {
          final savedValue = formData[key]?.toString() ?? '';
          _page5RadioSelections[key] = savedValue;
        }
      });

      // Load signatures
      _page5Signatures.clear();
      if (formData.containsKey('page5_signatures') && formData['page5_signatures'] != null) {
        final signaturesData = formData['page5_signatures'];
        print('Loading Page 5 signatures data type: ${signaturesData.runtimeType}');

        if (signaturesData is Map<String, dynamic>) {
          // Normal case - signatures stored as Map
          signaturesData.forEach((key, value) {
            if (value != null && value is String && value.isNotEmpty) {
              try {
                final decodedSignature = base64Decode(value);
                _page5Signatures[key] = decodedSignature;
                print('Successfully loaded Page 5 signature for key: $key, size: ${decodedSignature.length}');
              } catch (e) {
                print('Failed to decode Page 5 signature for key $key: $e');
              }
            }
          });
        } else if (signaturesData is String) {
          // Handle string format if needed
          try {
            final Map<String, dynamic> parsedSignatures = json.decode(signaturesData);
            parsedSignatures.forEach((key, value) {
              if (value is String && value.isNotEmpty) {
                try {
                  final decodedSignature = base64Decode(value);
                  _page5Signatures[key] = decodedSignature;
                  print('Successfully loaded Page 5 signature for key: $key, size: ${decodedSignature.length}');
                } catch (e) {
                  print('Failed to decode Page 5 signature for key $key: $e');
                }
              }
            });
          } catch (e) {
            print('Failed to parse Page 5 signatures string: $e');
          }
        }
      }

      print('Final Page 5 signatures map: ${_page5Signatures.keys.toList()}');
      print('Total Page 5 signatures loaded: ${_page5Signatures.length}');

      // Trigger UI rebuild to show loaded data
      setState(() {});

      print('Data loaded successfully');

    } catch (e) {
      print('Error loading existing data: $e');
    }
  }

  void _onPage5SignatureChanged(String key, Uint8List? signature) {
    setState(() {
      if (signature != null) {
        _page5Signatures[key] = signature;
        print('Page 5 signature updated for key: $key, size: ${signature.length}');
      } else {
        _page5Signatures.remove(key);
        print('Page 5 signature removed for key: $key');
      }
    });

    // Auto-save the signatures
    _autoSavePage5();
  }

  Future<void> _addAutoGeneratedFields() async {
    try {
      // Check if auto fields already exist
      if (widget.form.formData.containsKey('report_no') &&
          widget.form.formData.containsKey('today_date')) {
        print('Auto fields already exist');
      } else {
        final reportNumber = await _generateNextReportNumber();

        // Format date as DD.MM.YYYY
        final now = DateTime.now();
        final todayDate = '${now.day.toString().padLeft(2, '0')}.${now.month.toString().padLeft(2, '0')}.${now.year}';

        final autoData = {
          'report_no': reportNumber,
          'today_date': todayDate, // Will be something like "15.01.2024"
        };

        print('Generating auto fields: $autoData');

        final success = await context.read<FormProvider>().saveFormData(
            widget.form.id!, autoData);

        if (success) {
          print('Auto fields saved successfully');
          widget.form.formData.addAll(autoData);
        }
      }

      await _autoPopulatePage5Fields();

      if (mounted) {
        setState(() {});
      }

    } catch (e) {
      print('Error generating auto fields: $e');
    }
  }

  Future<void> _autoPopulatePage5Fields() async {
    try {
      // Calculate scadenta_verificare (2 years from report date)
      final reportDate = widget.form.reportDate;
      final scadentaDate = reportDate.add(Duration(days: 365 * 2));
      final scadentaFormatted = '${scadentaDate.day.toString().padLeft(2, '0')}.${scadentaDate.month.toString().padLeft(2, '0')}.${scadentaDate.year}';

      // Auto-populated data
      final autoData = {
        'scadenta_verificare': scadentaFormatted,
        'nume_utilizator': widget.client.name,
        'nume_personal_instruit': widget.client.name,
      };

      print('Auto-populating Page 5 fields: $autoData');

      // Save the auto-populated data
      final success = await context.read<FormProvider>().saveFormData(
        widget.form.id!,
        autoData,
      );

      if (success) {
        print('Page 5 auto-populated fields saved successfully');
        // Update the form data immediately so it shows in the UI
        widget.form.formData.addAll(autoData);
      } else {
        print('Failed to save Page 5 auto-populated fields');
      }

    } catch (e) {
      print('Error auto-populating Page 5 fields: $e');
    }
  }

  Future<String> _generateNextReportNumber() async {
    try {
      // Get total count of ALL forms ever created
      final totalFormsCount = await DatabaseService.instance
          .getTotalFormsCount();

      // Generate report number: next number in sequence
      final nextNumber = totalFormsCount + 1;

      return '$nextNumber';
    } catch (e) {
      print('Error generating report number: $e');
      // Fallback: use a simple timestamp-based number
      final now = DateTime.now();
      return now.millisecondsSinceEpoch.toString().substring(8, 11);
    }
  }
}